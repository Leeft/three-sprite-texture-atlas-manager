{"version":3,"sources":["three-sprite-texture-atlas-manager.umd.min.js","/source/three-sprite-texture-atlas-manager.umd.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","threeSpriteAtlasTextureManager","this","KnapsackRectangle","left","top","right","bottom","Math","floor","isFinite","get","KnapsackNode","knapsack","leftChild","rightChild","rectangle","textureSize","imageID","_texture","value","size","hasChildren","Error","dispose","clear","context","clearRect","width","height","ctx","save","beginPath","rect","clip","translate","Xcentre","Ycentre","restore","newNode","allocate","claim","isOccupied","remainingWidth","remainingHeight","textureManager","debug","lineWidth","strokeStyle","strokeRect","THREE","generateUUID","canvas","getContext","rootTexture","clone","uuid","uvs","uvCoordinates","texture","offset","x","y","repeat","Knapsack","textureLoaded","rootNode","_rootTexture","_canvas","document","createElement","Texture","UVMapping","TextureManager","test","knapsacks","push","console","log","_validateSize","_allocate","_this","Promise","resolve","reject","error","_this2","Array","isArray","_queue","queueEntry","undefined","promise","_this3","promises","forEach","entry","node","all","allocateNode","_addKnapsack","release"],"mappings":"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","file":"three-sprite-texture-atlas-manager.umd.min.js","sourcesContent":["var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.threeSpriteAtlasTextureManager = factory();\n})(this, function () {\n  'use strict';\n\n  /**\n  Describes a rectangular area witin the knapsack. Abstracts the basic math away from the {@link module:texture-manager/knapsack/node|`KnapsackNode`} module.\n   @module texture-manager/knapsack/rectangle\n  */\n\n  /**\n   * @constructor\n   * @param {integer} left - Left most pixel index of this rectangle (0 to `right` - 1 )\n   * @param {integer} top - Top most pixel index of this rectangle (0 to `bottom` - 1 )\n   * @param {integer} right - Right most pixel index of this rectangle\n   * @param {integer} bottom - Bottom most pixel index of this rectangle\n  */\n\n  var KnapsackRectangle = (function () {\n    function KnapsackRectangle(left, top, right, bottom) {\n      _classCallCheck(this, KnapsackRectangle);\n\n      this.left = Math.floor(typeof left === 'number' && isFinite(left) ? left : 0);\n      this.top = Math.floor(typeof top === 'number' && isFinite(top) ? top : 0);\n      this.right = Math.floor(typeof right === 'number' && isFinite(right) ? right : 0);\n      this.bottom = Math.floor(typeof bottom === 'number' && isFinite(bottom) ? bottom : 0);\n    }\n\n    /**\n     * Do not use this directly, it is managed for you.\n     * @constructor\n     * @param {Knapsack} - The {@link module:texture-manager/knapsack|`Knapsack`} this node is to become a part of.\n     */\n\n    /**\n     * The center X coordinate of this rectangle.\n     * @type {integer}\n     * @readonly\n     */\n\n    _createClass(KnapsackRectangle, [{\n      key: 'Xcentre',\n      get: function get() {\n        return Math.floor((this.right - this.left) / 2 + this.left) - 0.5;\n      }\n\n      /**\n       * The center Y coordinate of this rectangle.\n       * @type {integer}\n       * @readonly\n       */\n    }, {\n      key: 'Ycentre',\n      get: function get() {\n        return Math.floor((this.bottom - this.top) / 2 + this.top) - 0.5;\n      }\n\n      /**\n       * The width of this rectangle in pixels.\n       * @type {integer}\n       * @readonly\n       */\n    }, {\n      key: 'width',\n      get: function get() {\n        return this.right - this.left;\n      }\n\n      /**\n       * The height of this rectangle in pixels.\n       * @type {integer}\n       * @readonly\n       */\n    }, {\n      key: 'height',\n      get: function get() {\n        return this.bottom - this.top;\n      }\n    }]);\n\n    return KnapsackRectangle;\n  })();\n\n  var KnapsackNode = (function () {\n    function KnapsackNode(knapsack) {\n      _classCallCheck(this, KnapsackNode);\n\n      /**\n       * Reference to the {@link module:texture-manager/knapsack|`Knapsack`} this node is a part of\n       * @type {Knapsack}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.knapsack = knapsack;\n\n      /**\n       * Optional reference to the \"left\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.leftChild = null;\n\n      /**\n       * Optional reference to the \"right\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.rightChild = null;\n\n      /**\n       * Describes the coordinates which are the boundaries of this node.\n       * @type {KnapsackRectangle}\n       * @private\n       * @readonly\n       * @category information\n       */\n      this.rectangle = null;\n      // Overwritten when children are created, but done as a default here to keep\n      // the code cleaner. Instantiating this object is pretty cheap anyway.\n      this.rectangle = new KnapsackRectangle(0, 0, knapsack.textureSize, knapsack.textureSize);\n\n      /**\n       * Internal unique ID for the image this node represents.\n       * @type {string}\n       * @private\n       * @readonly\n       * @category information\n       */\n      this.imageID = null;\n\n      this._texture = null;\n    }\n\n    /**\n      * @constructor\n      * @param {TextureManager} textureManager - The {@link module:texture-manager|`TextureManager`} which created this `Knapsack`\n      * @param {integer} size - The size of the texture\n      */\n\n    /**\n     * The HTML `<canvas>` element as supplied by the {@link module:texture-manager/knapsack|`Knapsack`} which this node is part of.\n     * @type {external:canvas}\n     * @readonly\n     * @category provider\n     */\n\n    _createClass(KnapsackNode, [{\n      key: 'hasChildren',\n\n      /**\n       * Returns true if this node has any children, which means it's not available to be drawn in. Its children may be suitable for this though.\n       * @returns {boolean}\n       * @category information\n       * @private\n       */\n      value: function hasChildren() {\n        return this.leftChild !== null || this.rightChild !== null;\n      }\n\n      /**\n       * Returns true if this node is available to be used by a texture (i.e. it's not yet been claimed by {@link module:texture-manager/knapsack/node#claim|`claim()`}.\n       * @returns {boolean} Indicates whether this node has been claimed or not.\n       * @category information\n       * @private\n       */\n    }, {\n      key: 'isOccupied',\n      value: function isOccupied() {\n        return this.imageID !== null;\n      }\n\n      /**\n       * The UV coordinates which describe where in the texture this node is located. This is probably not of any practical use to you as a user of this library; it is used internally to map the texture correctly to a sprite.\n       * @returns {Array} Array with [ left, top, right, bottom ] coordinates.\n       * @category information\n       * @example\n       * var uvs = node.uvCoordinates();\n       * var left   = uvs[ 0 ];\n       * var top    = uvs[ 1 ];\n       * var right  = uvs[ 2 ];\n       * var bottom = uvs[ 3 ];\n       */\n    }, {\n      key: 'uvCoordinates',\n      value: function uvCoordinates() {\n        var size = this.knapsack.textureSize;\n        return [this.rectangle.left / size, 1 - this.rectangle.bottom / size, this.rectangle.right / size, 1 - this.rectangle.top / size];\n      }\n\n      /**\n       * Release this node back to the {@link module:texture-manager/knapsack|`Knapsack`} where it is contained. This makes it available to be used by new sprites. Only nodes without children can be released, but a user of this library will only get these leaf nodes returned. Branch nodes are used internally only.\n       * @category allocation\n       * @example\n       * node.release();\n       * // or, if you like typing:\n       * textureManager.release( node );\n       */\n    }, {\n      key: 'release',\n      value: function release() {\n        if (this.hasChildren()) {\n          throw new Error('Can not release tree node, still has children');\n        }\n\n        if (this._texture !== null) {\n          this._texture.dispose();\n          this._texture = null;\n        }\n\n        this.clear();\n        this.imageID = null;\n\n        return;\n      }\n\n      /**\n       * Clear the area of this node: it erases the context so that it is empty and transparent, and ready to be drawn to.\n       * @category drawing\n       * @example\n       * // Erase the contents of the sprite\n       * node.clear();\n       */\n    }, {\n      key: 'clear',\n      value: function clear() {\n        this.context.clearRect(this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1);\n      }\n\n      /**\n       * Set the drawing context tailored towards the area of the sprite, clipping anything outside of it. When done drawing, use {@link module:texture-manager/knapsack/node#restoreContext|`restoreContext()`} to restore the original drawing context.\n       * @returns {CanvasRenderingContext2D} Render context configured exclusively for the sprite we're working on.\n       * @category drawing\n       * @example\n       * var context = node.clipContext();\n       * // Draw a 5px border along the edge of the sprite, some\n       * // of it will fall outside the area, but it is clipped.\n       * context.lineWidth = 5.0;\n       * context.strokeStyle = 'rgba(255,0,0,1)';\n       * context.strokeRect( 0, 0, node.width, node.height );\n       * // other drawing commands\n       * node.restoreContext();\n       */\n    }, {\n      key: 'clipContext',\n      value: function clipContext() {\n        var ctx = this.context;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2);\n        ctx.clip();\n        ctx.translate(this.rectangle.Xcentre, this.rectangle.Ycentre);\n        return ctx;\n      }\n\n      /**\n       * Restore the draw context of the {@link module:texture-manager/knapsack/node#canvas|`canvas`}. Call this when done drawing the sprite.\n       * @category drawing\n       * @example\n       * var context = node.clipContext();\n       * // Draw a 5px border along the edge of the sprite, some\n       * // of it will fall outside the area, but it is clipped.\n       * context.lineWidth = 5.0;\n       * context.strokeStyle = 'rgba(255,0,0,1)';\n       * context.strokeRect( 0, 0, node.width, node.height );\n       * // other drawing commands\n       * node.restoreContext();\n       */\n    }, {\n      key: 'restoreContext',\n      value: function restoreContext() {\n        this.context.restore();\n      }\n\n      /**\n       * Allocate a node in this {@link module:texture-manager/knapsack|`Knapsack`} for the given width and height. This is the main workhorse of this library.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {KnapsackNode} A new node which describes a rectangular area in the knapsack.\n       * @ignore\n       * @category allocation\n       */\n    }, {\n      key: 'allocate',\n      value: function allocate(width, height) {\n        // If we're not a leaf node\n        if (this.hasChildren()) {\n          // then try inserting into our first child\n          var newNode = this.leftChild.allocate(width, height);\n          if (newNode instanceof KnapsackNode) {\n            newNode.claim();\n            return newNode;\n          }\n\n          // There was no room: try to insert into second child\n          return this.rightChild.allocate(width, height);\n        } else {\n          // if there's already an image here, return\n          if (this.isOccupied()) {\n            return null;\n          }\n\n          // if this node is too small, give up here\n          if (width > this.width || height > this.height) {\n            return null;\n          }\n\n          // if we're just the right size, accept\n          if (width === this.width && height === this.height) {\n            this.claim();\n            return this;\n          }\n\n          // otherwise, got to split this node and create some kids\n          this.leftChild = new KnapsackNode(this.knapsack);\n          this.rightChild = new KnapsackNode(this.knapsack);\n\n          // now decide which way to split\n          var remainingWidth = this.width - width;\n          var remainingHeight = this.height - height;\n\n          if (remainingWidth > remainingHeight) {\n            // horizontal split\n            this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.left + width, this.rectangle.bottom);\n\n            this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left + width, this.rectangle.top, this.rectangle.right, this.rectangle.bottom);\n          } else {\n            // vertical split\n            this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.right, this.rectangle.top + height);\n\n            this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top + height, this.rectangle.right, this.rectangle.bottom);\n          }\n\n          // Some crude painting to help troubleshooting\n          if (this.knapsack.textureManager.debug) {\n            var context = this.context;\n            context.lineWidth = 4.0;\n            context.strokeStyle = 'rgba(255,0,0,1)';\n            context.strokeRect(this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height);\n\n            context.lineWidth = 4.0;\n            context.strokeStyle = 'rgba(0,255,0,1)';\n            context.strokeRect(this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height);\n          }\n\n          // Recurse into the first child to continue the allocation\n          return this.leftChild.allocate(width, height);\n        }\n      }\n\n      /**\n       * Claim the node to be in use by giving it a (unique) ID for an image, this prevents it from being used for another image. After calling this method it is ready to be drawn.\n       * @ignore\n       * @category allocation\n       */\n    }, {\n      key: 'claim',\n      value: function claim() {\n        this.imageID = THREE.Math.generateUUID();\n\n        // Some crude painting to help troubleshooting\n        if (this.knapsack.textureManager.debug) {\n          var context = this.context;\n          context.lineWidth = 2.0;\n          context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n          context.strokeRect(this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1);\n        }\n      }\n    }, {\n      key: 'canvas',\n      get: function get() {\n        return this.knapsack.canvas;\n      }\n\n      /**\n       * Convenience accessor for the {@link external:CanvasRenderingContext2D} which is associated with the {@link module:texture-manager/knapsack/node#canvas}. You can use this context to draw on the entire canvas, but you'll probably want to use {@link module:texture-manager/knapsack/node#clipContext|`clipContext()`} instead.\n       * @type {external:CanvasRenderingContext2D}\n       * @readonly\n       * @category provider\n       */\n    }, {\n      key: 'context',\n      get: function get() {\n        return this.knapsack.canvas.getContext('2d');\n      }\n\n      /**\n       * The width in pixels of this sprite's texture node.\n       * @type {integer}\n       * @readonly\n       * @category information\n       * @example\n       * textureManager.allocateNode( 30, 10 ).then( function( node ) {\n       *   console.log( node.width ); // => 30\n       * });\n       */\n    }, {\n      key: 'width',\n      get: function get() {\n        return this.rectangle.width;\n      }\n\n      /**\n       * The height in pixels of this sprite's texture node.\n       * @type {integer}\n       * @readonly\n       * @category information\n       * @example\n       * textureManager.allocateNode( 30, 10 ).then( function( node ) {\n       *   console.log( node.height ); // => 10\n       * });\n       */\n    }, {\n      key: 'height',\n      get: function get() {\n        return this.rectangle.height;\n      }\n\n      /**\n       * Lazily built {@link external:Texture|`THREE.Texture`}, with it's UV coordinates already set for you. You can pass this texture straight to your material, and the GPU memory it requires should be shared with all other texture nodes on the same texture.\n       * @type {external:Texture}\n       * @readonly\n       * @category provider\n       * @example\n       * var material = new THREE.SpriteMaterial({\n       *   map: node.texture,\n       *   transparent: true,\n       *   blending: THREE.AdditiveBlending\n       * });\n       * var sprite = new THREE.Sprite( material );\n       * scene.add( sprite );\n       */\n    }, {\n      key: 'texture',\n      get: function get() {\n        if (!this._texture) {\n          this._texture = this.knapsack.rootTexture.clone();\n          this._texture.uuid = this.knapsack.rootTexture.uuid;\n          var uvs = this.uvCoordinates();\n          this.texture.offset.x = uvs[0];\n          this.texture.offset.y = uvs[1];\n          this.texture.repeat.x = uvs[2] - uvs[0];\n          this.texture.repeat.y = uvs[3] - uvs[1];\n        }\n        return this._texture;\n      }\n    }]);\n\n    return KnapsackNode;\n  })();\n\n  var Knapsack = (function () {\n    function Knapsack(textureManager, size) {\n      _classCallCheck(this, Knapsack);\n\n      this.textureManager = textureManager;\n      this.textureSize = size;\n      this.textureLoaded = false;\n      this.rootNode = new KnapsackNode(this);\n      // Lazy initialising these:\n      this._rootTexture = null;\n      this._canvas = null;\n    }\n\n    /**\n      * @constructor\n      * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n      * @example\n      * // We want 512x512 pixel textures\n      * var textureManager = new TextureManager( 512 );\n      * ...\n      * textureManager.allocateNode( ... );\n      */\n\n    /**\n     * Lazily built HTML `<canvas>` element for this `Knapsack`.\n     * @type {external:canvas}\n     * @readonly\n     */\n\n    _createClass(Knapsack, [{\n      key: 'allocateNode',\n\n      /**\n       * Proxy method, allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {external:Promise}\n       */\n      value: function allocateNode(width, height) {\n        return this.rootNode.allocate(width, height);\n      }\n    }, {\n      key: 'canvas',\n      get: function get() {\n        if (!this._canvas) {\n          this._canvas = document.createElement('canvas');\n          this._canvas.width = this.textureSize;\n          this._canvas.height = this.textureSize;\n        }\n        return this._canvas;\n      }\n\n      /**\n       * Lazily built {@link external:Texture|`THREE.Texture`}, this is created as a \"master\" texture. Each node will get its own `.clone()`, which should be shared in memory.\n       * @type {external:Texture}\n       * @readonly\n       */\n    }, {\n      key: 'rootTexture',\n      get: function get() {\n        if (!this._rootTexture) {\n          this._rootTexture = new THREE.Texture(this.canvas, THREE.UVMapping);\n        }\n        return this._rootTexture;\n      }\n    }]);\n\n    return Knapsack;\n  })();\n\n  var TextureManager = (function () {\n    function TextureManager(size) {\n      _classCallCheck(this, TextureManager);\n\n      /**\n       * The size of the textures as was validated when constructing the object.\n       * @namespace module:texture-manager~TextureManager#size\n       * @type {integer}\n       * @ignore\n       * @category readonly\n       */\n      this.size = typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test(size) ? size : 1024;\n\n      /**\n       * As the texture manager allocates nodes, it creates a new {@link module:texture-manager/knapsack|`Knapsack`} when it needs to provide space for nodes. This is an array with all the knapsacks which have been created.\n       * @namespace module:texture-manager~TextureManager#knapsacks\n       * @type {Knapsack[]}\n       * @readonly\n       * @category readonly\n       * @example\n       * // Show the canvases in the DOM element with id=\"canvases\"\n       * // (you'd normally do this from the browser console)\n       * textureManager.knapsacks.forEach( function( knapsack ) {\n       *   document.getElementById('canvases').appendChild( knapsack.canvas );\n       * });\n       */\n      this.knapsacks = [];\n\n      /**\n       * The debug property can be set to `true` after instantiating the object, which will make the {@link module:texture-manager/knapsack/node|`KnapsackNode`} class draw outlines as it allocates nodes. This can make it much more obvious what is going on, such as whether your text is properly sized and centered.\n       * @namespace module:texture-manager~TextureManager#debug\n       * @type {boolean}\n       * @example\n       * textureManager.debug = true;\n       */\n      this.debug = false;\n    }\n\n    /**\n     * Add a new knapsack to the texture manager.\n     * @param {integer} size\n     * @returns {Knapsack}\n     * @ignore\n     */\n\n    _createClass(TextureManager, [{\n      key: '_addKnapsack',\n      value: function _addKnapsack(size) {\n        var knapsack = new Knapsack(this, size);\n        this.knapsacks.push(knapsack);\n        if (this.debug) {\n          console.log('TextureManager: allocated ' + this.textureSize + 'px texture map #' + this.knapsacks.length);\n        }\n        return knapsack;\n      }\n\n      /**\n       * The actual used size of the texture.\n       * @type {integer}\n       * @readonly\n       * @category readonly\n       */\n    }, {\n      key: 'allocate',\n\n      /**\n       * Allocate a texture atlas node for a sprite image of `width` by `height` pixels. Unlike allocateNode, it does not return a {external:Promise} and it works synchronously.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {KnapsackNode}\n       * @category allocation\n       * @throws {Error} The given with and height must fit in the texture.\n       * @example\n       * let node = textureManager.allocate( 100, 20 );\n       */\n      value: function allocate(width, height) {\n        var node = null;\n\n        // Prevent allocating knapsacks when there's no chance to fit the node\n        // FIXME TODO: try a bigger texture size if it doesn't fit?\n        this._validateSize(width, height);\n        return this._allocate(width, height);\n      }\n\n      /**\n       * {external:Promise} based version of {@link allocate}.\n       *\n       * This method will require you to use a {external:Promise} polyfill if you want to support IE11 or older, as that browser doesn't support promises natively.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {external:Promise}\n       * @category allocation\n       * @example\n       * textureManager.allocateNode( 100, 20 ).then(\n       *   function( node ) {\n       *     // Do something with the node in this Promise, such as\n       *     // creating a sprite and adding it to the scene.\n       *   },\n       *   function( error ) {\n       *     // Promise was rejected\n       *     console.error( \"Could not allocate node:\", error );\n       *   }\n       * );\n       */\n    }, {\n      key: 'allocateNode',\n      value: function allocateNode(width, height) {\n        var _this = this;\n\n        return new Promise(function (resolve, reject) {\n          try {\n            // Prevent allocating knapsacks when there's no chance to fit the node\n            // FIXME TODO: try a bigger texture size if it doesn't fit?\n            _this._validateSize(width, height);\n            resolve(_this._allocate(width, height));\n          } catch (error) {\n            reject(error);\n          };\n        });\n      }\n\n      /**\n       * Asynchronously allocate a texture atlas node for a sprite image of `width` by `height` pixels. Returns a result through resolving the promise. The asynchronous approach will potentially allow for better optimisation of packing nodes in the texture space.\n       *\n       * When done adding nodes, you should call {@link solveASync}. Your queued promises will then be settled. But note that the {external:Promise} will still be rejected straight away if the given width or height don't fit.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {external:Promise}\n       * @category allocation\n       * @example\n       * // First prepare all your node allocations:\n       * [ 1, 2, 3 ].forEach( function() {\n       *   textureManager.allocateASync( 100, 20 ).then(\n       *     function( node ) {\n       *       // Do something with the node in this Promise, such as\n       *       // creating a sprite and adding it to the scene.\n       *       // Note: this promise won't succesfully settle until\n       *       // after you also called solveASync!\n       *     },\n       *     function( error ) {\n       *       // Promise was rejected\n       *       console.error( \"Could not allocate node:\", error );\n       *     }\n       *   );\n       * });\n       * // Then resolve all the outstanding allocations:\n       * textureManager.solveASync().then( function( result ) {\n       *   console.log( `${ result.length } allocations have resolved` );\n       * });\n       */\n    }, {\n      key: 'allocateASync',\n      value: function allocateASync(width, height) {\n        var _this2 = this;\n\n        if (!Array.isArray(this._queue)) {\n          this._queue = [];\n        }\n\n        var queueEntry = undefined;\n\n        var promise = new Promise(function (resolve, reject) {\n          try {\n            // Prevent allocating knapsacks when there's no chance to fit the node\n            // FIXME TODO: try a bigger texture size if it doesn't fit?\n            _this2._validateSize(width, height);\n            // Queue our resolution, which will be settled with .solveASync()\n            queueEntry = {\n              resolve: resolve,\n              reject: reject,\n              width: width,\n              height: height\n            };\n          } catch (error) {\n            reject(error);\n          };\n        });\n\n        if (queueEntry) {\n          queueEntry.promise = promise;\n          this._queue.push(queueEntry);\n        }\n\n        return promise;\n      }\n\n      /**\n       * Trigger resolution of any outstanding node allocation promises, i.e. those that have been created with {@link allocateASync}. Call this when you've added nodes, or their promises will not settle.\n       *\n       * This is by design, as postponing of the node allocation makes it possible for the texture manager to optimise packing of the texture space in the most efficient manner possible.\n       * @returns {external:Promise}\n       * @category allocation\n       * @throws {Error} You're trying to resolve a queue which hasn't been set up. Call {@link allocateASync} at least once before calling this.\n       * @example\n       * textureManager.solveASync().then( function( count ) {\n       *   console.log( `${ count } node allocations have been resolved` );\n       * });\n       */\n    }, {\n      key: 'solveASync',\n      value: function solveASync() {\n        var _this3 = this;\n\n        if (!Array.isArray(this._queue)) {\n          throw new Error('You\\'re trying to resolve a queue which hasn\\'t been set up. Call allocateASync before using this.');\n        }\n\n        var promises = [];\n\n        this._queue.forEach(function (entry) {\n          var promise = entry.promise;\n          var resolve = entry.resolve;\n          var reject = entry.reject;\n          var width = entry.width;\n          var height = entry.height;\n\n          var node = _this3._allocate(width, height);\n          resolve(node);\n          promises.push(promise);\n        });\n\n        this._queue = [];\n\n        return Promise.all(promises);\n      }\n\n      /**\n       * Low level helper to assert whether the given width and height will fit.\n       * @param {integer} width\n       * @param {integer} height\n       * @category allocation\n       * @throws {Error} Width of <number> is too large for these textures.\n       * @throws {Error} Height of <number> is too large for these textures.\n       * @private\n       * @ignore\n       */\n    }, {\n      key: '_validateSize',\n      value: function _validateSize(width, height) {\n        if (width > this.textureSize) {\n          throw new Error('Width of ' + width + ' is too large for these textures');\n        }\n\n        if (height > this.textureSize) {\n          throw new Error('Height of ' + height + ' is too large for these textures');\n        }\n      }\n\n      /**\n       * Low level helper to allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n       * @param {integer} width\n       * @param {integer} height\n       * @returns {KnapsackNode}\n       * @category allocation\n       * @private\n       * @ignore\n       */\n    }, {\n      key: '_allocate',\n      value: function _allocate(width, height) {\n        var node = null;\n\n        // First try to get a node from the existing knapsacks\n        this.knapsacks.forEach(function (knapsack) {\n          if (node === null || node === undefined) {\n            node = knapsack.allocateNode(width, height);\n          }\n        });\n\n        // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n        if (node === null) {\n          var knapsack = this._addKnapsack(this.textureSize);\n          node = knapsack.allocateNode(width, height);\n        }\n\n        return node;\n      }\n\n      /**\n       * Release the given node.\n       * @param {KnapsackNode} node\n       * @category allocation\n       * @example\n       * textureManager.release( node );\n       */\n    }, {\n      key: 'release',\n      value: function release(node) {\n        if (node) {\n          node.release();\n        }\n      }\n    }, {\n      key: 'textureSize',\n      get: function get() {\n        return this.size;\n      }\n    }]);\n\n    return TextureManager;\n  })();\n\n  return TextureManager;\n});\n//# sourceMappingURL=three-sprite-texture-atlas-manager.umd.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.threeSpriteAtlasTextureManager = factory();\n}(this, function () { 'use strict';\n\n  /**\n  Describes a rectangular area witin the knapsack. Abstracts the basic math away from the {@link module:texture-manager/knapsack/node|`KnapsackNode`} module.\n\n  @module texture-manager/knapsack/rectangle\n  */\n\n  /**\n   * @constructor\n   * @param {integer} left - Left most pixel index of this rectangle (0 to `right` - 1 )\n   * @param {integer} top - Top most pixel index of this rectangle (0 to `bottom` - 1 )\n   * @param {integer} right - Right most pixel index of this rectangle\n   * @param {integer} bottom - Bottom most pixel index of this rectangle\n  */\n\n  class KnapsackRectangle {\n    constructor( left, top, right, bottom ) {\n      this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n      this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n      this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n      this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n    }\n\n    /**\n     * The center X coordinate of this rectangle.\n     * @type {integer}\n     * @readonly\n     */\n    get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n\n    /**\n     * The center Y coordinate of this rectangle.\n     * @type {integer}\n     * @readonly\n     */\n    get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n\n    /**\n     * The width of this rectangle in pixels.\n     * @type {integer}\n     * @readonly\n     */\n    get width ()  { return ( this.right - this.left ); }\n\n    /**\n     * The height of this rectangle in pixels.\n     * @type {integer}\n     * @readonly\n     */\n    get height () { return ( this.bottom - this.top ); }\n  }\n\n  /**\n   * Do not use this directly, it is managed for you.\n   * @constructor\n   * @param {Knapsack} - The {@link module:texture-manager/knapsack|`Knapsack`} this node is to become a part of.\n   */\n  class KnapsackNode {\n    constructor( knapsack ) {\n      /**\n       * Reference to the {@link module:texture-manager/knapsack|`Knapsack`} this node is a part of\n       * @type {Knapsack}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.knapsack = knapsack;\n\n      /**\n       * Optional reference to the \"left\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.leftChild = null;\n\n      /**\n       * Optional reference to the \"right\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       * @category provider\n       */\n      this.rightChild = null;\n\n      /**\n       * Describes the coordinates which are the boundaries of this node.\n       * @type {KnapsackRectangle}\n       * @private\n       * @readonly\n       * @category information\n       */\n      this.rectangle = null;\n      // Overwritten when children are created, but done as a default here to keep\n      // the code cleaner. Instantiating this object is pretty cheap anyway.\n      this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n\n      /**\n       * Internal unique ID for the image this node represents.\n       * @type {string}\n       * @private\n       * @readonly\n       * @category information\n       */\n      this.imageID = null;\n\n      this._texture = null;\n    }\n\n    /**\n     * The HTML `<canvas>` element as supplied by the {@link module:texture-manager/knapsack|`Knapsack`} which this node is part of.\n     * @type {external:canvas}\n     * @readonly\n     * @category provider\n     */\n    get canvas () { return this.knapsack.canvas; }\n\n    /**\n     * Convenience accessor for the {@link external:CanvasRenderingContext2D} which is associated with the {@link module:texture-manager/knapsack/node#canvas}. You can use this context to draw on the entire canvas, but you'll probably want to use {@link module:texture-manager/knapsack/node#clipContext|`clipContext()`} instead.\n     * @type {external:CanvasRenderingContext2D}\n     * @readonly\n     * @category provider\n     */\n    get context () { return this.knapsack.canvas.getContext('2d'); }\n\n    /**\n     * The width in pixels of this sprite's texture node.\n     * @type {integer}\n     * @readonly\n     * @category information\n     * @example\n     * textureManager.allocateNode( 30, 10 ).then( function( node ) {\n     *   console.log( node.width ); // => 30\n     * });\n     */\n    get width () { return this.rectangle.width; }\n\n    /**\n     * The height in pixels of this sprite's texture node.\n     * @type {integer}\n     * @readonly\n     * @category information\n     * @example\n     * textureManager.allocateNode( 30, 10 ).then( function( node ) {\n     *   console.log( node.height ); // => 10\n     * });\n     */\n    get height () { return this.rectangle.height; }\n\n    /**\n     * Lazily built {@link external:Texture|`THREE.Texture`}, with it's UV coordinates already set for you. You can pass this texture straight to your material, and the GPU memory it requires should be shared with all other texture nodes on the same texture.\n     * @type {external:Texture}\n     * @readonly\n     * @category provider\n     * @example\n     * var material = new THREE.SpriteMaterial({\n     *   map: node.texture,\n     *   transparent: true,\n     *   blending: THREE.AdditiveBlending\n     * });\n     * var sprite = new THREE.Sprite( material );\n     * scene.add( sprite );\n     */\n    get texture () {\n      if ( ! this._texture ) {\n        this._texture = this.knapsack.rootTexture.clone();\n        this._texture.uuid = this.knapsack.rootTexture.uuid;\n        var uvs = this.uvCoordinates();\n        this.texture.offset.x = uvs[ 0 ];\n        this.texture.offset.y = uvs[ 1 ];\n        this.texture.repeat.x = uvs[ 2 ] - uvs[ 0 ];\n        this.texture.repeat.y = uvs[ 3 ] - uvs[ 1 ];\n      }\n      return this._texture;\n    }\n\n    /**\n     * Returns true if this node has any children, which means it's not available to be drawn in. Its children may be suitable for this though.\n     * @returns {boolean}\n     * @category information\n     * @private\n     */\n    hasChildren() {\n      return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n    }\n\n    /**\n     * Returns true if this node is available to be used by a texture (i.e. it's not yet been claimed by {@link module:texture-manager/knapsack/node#claim|`claim()`}.\n     * @returns {boolean} Indicates whether this node has been claimed or not.\n     * @category information\n     * @private\n     */\n    isOccupied() {\n      return ( this.imageID !== null );\n    }\n\n    /**\n     * The UV coordinates which describe where in the texture this node is located. This is probably not of any practical use to you as a user of this library; it is used internally to map the texture correctly to a sprite.\n     * @returns {Array} Array with [ left, top, right, bottom ] coordinates.\n     * @category information\n     * @example\n     * var uvs = node.uvCoordinates();\n     * var left   = uvs[ 0 ];\n     * var top    = uvs[ 1 ];\n     * var right  = uvs[ 2 ];\n     * var bottom = uvs[ 3 ];\n     */\n    uvCoordinates() {\n      var size = this.knapsack.textureSize;\n      return [\n            ( this.rectangle.left   / size ),\n        1 - ( this.rectangle.bottom / size ),\n            ( this.rectangle.right  / size ),\n        1 - ( this.rectangle.top    / size ),\n      ];\n    }\n\n    /**\n     * Release this node back to the {@link module:texture-manager/knapsack|`Knapsack`} where it is contained. This makes it available to be used by new sprites. Only nodes without children can be released, but a user of this library will only get these leaf nodes returned. Branch nodes are used internally only.\n     * @category allocation\n     * @example\n     * node.release();\n     * // or, if you like typing:\n     * textureManager.release( node );\n     */\n    release() {\n      if ( this.hasChildren() ) {\n        throw new Error( 'Can not release tree node, still has children' );\n      }\n\n      if ( this._texture !== null ) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n\n      this.clear();\n      this.imageID = null;\n\n      return;\n    }\n\n    /**\n     * Clear the area of this node: it erases the context so that it is empty and transparent, and ready to be drawn to.\n     * @category drawing\n     * @example\n     * // Erase the contents of the sprite\n     * node.clear();\n     */\n    clear() {\n      this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n    }\n\n    /**\n     * Set the drawing context tailored towards the area of the sprite, clipping anything outside of it. When done drawing, use {@link module:texture-manager/knapsack/node#restoreContext|`restoreContext()`} to restore the original drawing context.\n     * @returns {CanvasRenderingContext2D} Render context configured exclusively for the sprite we're working on.\n     * @category drawing\n     * @example\n     * var context = node.clipContext();\n     * // Draw a 5px border along the edge of the sprite, some\n     * // of it will fall outside the area, but it is clipped.\n     * context.lineWidth = 5.0;\n     * context.strokeStyle = 'rgba(255,0,0,1)';\n     * context.strokeRect( 0, 0, node.width, node.height );\n     * // other drawing commands\n     * node.restoreContext();\n     */\n    clipContext() {\n      var ctx = this.context;\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n      ctx.clip();\n      ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n      return ctx;\n    }\n\n    /**\n     * Restore the draw context of the {@link module:texture-manager/knapsack/node#canvas|`canvas`}. Call this when done drawing the sprite.\n     * @category drawing\n     * @example\n     * var context = node.clipContext();\n     * // Draw a 5px border along the edge of the sprite, some\n     * // of it will fall outside the area, but it is clipped.\n     * context.lineWidth = 5.0;\n     * context.strokeStyle = 'rgba(255,0,0,1)';\n     * context.strokeRect( 0, 0, node.width, node.height );\n     * // other drawing commands\n     * node.restoreContext();\n     */\n    restoreContext() {\n      this.context.restore();\n    }\n\n    /**\n     * Allocate a node in this {@link module:texture-manager/knapsack|`Knapsack`} for the given width and height. This is the main workhorse of this library.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {KnapsackNode} A new node which describes a rectangular area in the knapsack.\n     * @ignore\n     * @category allocation\n     */\n    allocate( width, height ) {\n      // If we're not a leaf node\n      if ( this.hasChildren() )\n      {\n        // then try inserting into our first child\n        var newNode = this.leftChild.allocate( width, height );\n        if ( newNode instanceof KnapsackNode ) {\n          newNode.claim();\n          return newNode;\n        }\n\n        // There was no room: try to insert into second child\n        return this.rightChild.allocate( width, height );\n      }\n      else\n      {\n        // if there's already an image here, return\n        if ( this.isOccupied() ) {\n          return null;\n        }\n\n        // if this node is too small, give up here\n        if ( ( width > this.width ) || ( height > this.height ) ) {\n          return null;\n        }\n\n        // if we're just the right size, accept\n        if ( width === this.width && height === this.height ) {\n          this.claim();\n          return this;\n        }\n\n        // otherwise, got to split this node and create some kids\n        this.leftChild  = new KnapsackNode( this.knapsack );\n        this.rightChild = new KnapsackNode( this.knapsack );\n\n        // now decide which way to split\n        var remainingWidth  = this.width  - width;\n        var remainingHeight = this.height - height;\n\n        if ( remainingWidth > remainingHeight )\n        {\n          // horizontal split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.left + width,\n            this.rectangle.bottom\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left + width,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n        else\n        {\n          // vertical split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.top + height\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top + height,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n\n        // Some crude painting to help troubleshooting\n        if ( this.knapsack.textureManager.debug ) {\n          var context = this.context;\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(255,0,0,1)';\n          context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(0,255,0,1)';\n          context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n        }\n\n        // Recurse into the first child to continue the allocation\n        return this.leftChild.allocate( width, height );\n      }\n    }\n\n    /**\n     * Claim the node to be in use by giving it a (unique) ID for an image, this prevents it from being used for another image. After calling this method it is ready to be drawn.\n     * @ignore\n     * @category allocation\n     */\n    claim() {\n      this.imageID = THREE.Math.generateUUID();\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 2.0;\n        context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n        context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n      }\n    }\n  }\n\n  /**\n    * @constructor\n    * @param {TextureManager} textureManager - The {@link module:texture-manager|`TextureManager`} which created this `Knapsack`\n    * @param {integer} size - The size of the texture\n    */\n  class Knapsack {\n    constructor( textureManager, size ) {\n      this.textureManager = textureManager;\n      this.textureSize = size;\n      this.textureLoaded = false;\n      this.rootNode = new KnapsackNode( this );\n      // Lazy initialising these:\n      this._rootTexture = null;\n      this._canvas = null;\n    }\n\n    /**\n     * Lazily built HTML `<canvas>` element for this `Knapsack`.\n     * @type {external:canvas}\n     * @readonly\n     */\n    get canvas () {\n      if ( ! this._canvas ) {\n        this._canvas = document.createElement('canvas');\n        this._canvas.width  = this.textureSize;\n        this._canvas.height = this.textureSize;\n      }\n      return this._canvas;\n    }\n\n    /**\n     * Lazily built {@link external:Texture|`THREE.Texture`}, this is created as a \"master\" texture. Each node will get its own `.clone()`, which should be shared in memory.\n     * @type {external:Texture}\n     * @readonly\n     */\n    get rootTexture () {\n      if ( ! this._rootTexture ) {\n        this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n      }\n      return this._rootTexture;\n    }\n\n    /**\n     * Proxy method, allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {external:Promise}\n     */\n    allocateNode( width, height ) {\n      return this.rootNode.allocate( width, height );\n    }\n  }\n\n  /**\n    * @constructor\n    * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n    * @example\n    * // We want 512x512 pixel textures\n    * var textureManager = new TextureManager( 512 );\n    * ...\n    * textureManager.allocateNode( ... );\n    */\n  class TextureManager {\n    constructor( size ) {\n      /**\n       * The size of the textures as was validated when constructing the object.\n       * @namespace module:texture-manager~TextureManager#size\n       * @type {integer}\n       * @ignore\n       * @category readonly\n       */\n      this.size = ( ( typeof size === 'number' ) && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n\n      /**\n       * As the texture manager allocates nodes, it creates a new {@link module:texture-manager/knapsack|`Knapsack`} when it needs to provide space for nodes. This is an array with all the knapsacks which have been created.\n       * @namespace module:texture-manager~TextureManager#knapsacks\n       * @type {Knapsack[]}\n       * @readonly\n       * @category readonly\n       * @example\n       * // Show the canvases in the DOM element with id=\"canvases\"\n       * // (you'd normally do this from the browser console)\n       * textureManager.knapsacks.forEach( function( knapsack ) {\n       *   document.getElementById('canvases').appendChild( knapsack.canvas );\n       * });\n       */\n      this.knapsacks = [];\n\n      /**\n       * The debug property can be set to `true` after instantiating the object, which will make the {@link module:texture-manager/knapsack/node|`KnapsackNode`} class draw outlines as it allocates nodes. This can make it much more obvious what is going on, such as whether your text is properly sized and centered.\n       * @namespace module:texture-manager~TextureManager#debug\n       * @type {boolean}\n       * @example\n       * textureManager.debug = true;\n       */\n      this.debug = false;\n    }\n\n    /**\n     * Add a new knapsack to the texture manager.\n     * @param {integer} size\n     * @returns {Knapsack}\n     * @ignore\n     */\n    _addKnapsack( size ) {\n      var knapsack = new Knapsack( this, size );\n      this.knapsacks.push( knapsack );\n      if ( this.debug ) {\n        console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n      }\n      return knapsack;\n    }\n\n    /**\n     * The actual used size of the texture.\n     * @type {integer}\n     * @readonly\n     * @category readonly\n     */\n    get textureSize () {\n      return this.size;\n    }\n\n    /**\n     * Allocate a texture atlas node for a sprite image of `width` by `height` pixels. Unlike allocateNode, it does not return a {external:Promise} and it works synchronously.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {KnapsackNode}\n     * @category allocation\n     * @throws {Error} The given with and height must fit in the texture.\n     * @example\n     * let node = textureManager.allocate( 100, 20 );\n     */\n    allocate( width, height ) {\n      let node = null;\n\n      // Prevent allocating knapsacks when there's no chance to fit the node\n      // FIXME TODO: try a bigger texture size if it doesn't fit?\n      this._validateSize( width, height );\n      return this._allocate( width, height );\n    }\n\n    /**\n     * {external:Promise} based version of {@link allocate}.\n     *\n     * This method will require you to use a {external:Promise} polyfill if you want to support IE11 or older, as that browser doesn't support promises natively.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {external:Promise}\n     * @category allocation\n     * @example\n     * textureManager.allocateNode( 100, 20 ).then(\n     *   function( node ) {\n     *     // Do something with the node in this Promise, such as\n     *     // creating a sprite and adding it to the scene.\n     *   },\n     *   function( error ) {\n     *     // Promise was rejected\n     *     console.error( \"Could not allocate node:\", error );\n     *   }\n     * );\n     */\n    allocateNode( width, height ) {\n      return new Promise( ( resolve, reject ) => {\n        try {\n          // Prevent allocating knapsacks when there's no chance to fit the node\n          // FIXME TODO: try a bigger texture size if it doesn't fit?\n          this._validateSize( width, height );\n          resolve( this._allocate( width, height ) );\n        } catch ( error ) {\n          reject( error );\n        };\n      });\n    }\n\n    /**\n     * Asynchronously allocate a texture atlas node for a sprite image of `width` by `height` pixels. Returns a result through resolving the promise. The asynchronous approach will potentially allow for better optimisation of packing nodes in the texture space.\n     *\n     * When done adding nodes, you should call {@link solveASync}. Your queued promises will then be settled. But note that the {external:Promise} will still be rejected straight away if the given width or height don't fit.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {external:Promise}\n     * @category allocation\n     * @example\n     * // First prepare all your node allocations:\n     * [ 1, 2, 3 ].forEach( function() {\n     *   textureManager.allocateASync( 100, 20 ).then(\n     *     function( node ) {\n     *       // Do something with the node in this Promise, such as\n     *       // creating a sprite and adding it to the scene.\n     *       // Note: this promise won't succesfully settle until\n     *       // after you also called solveASync!\n     *     },\n     *     function( error ) {\n     *       // Promise was rejected\n     *       console.error( \"Could not allocate node:\", error );\n     *     }\n     *   );\n     * });\n     * // Then resolve all the outstanding allocations:\n     * textureManager.solveASync().then( function( result ) {\n     *   console.log( `${ result.length } allocations have resolved` );\n     * });\n     */\n    allocateASync( width, height ) {\n      if ( ! Array.isArray( this._queue ) ) {\n        this._queue = [];\n      }\n\n      let queueEntry;\n\n      const promise = new Promise( ( resolve, reject ) => {\n        try {\n          // Prevent allocating knapsacks when there's no chance to fit the node\n          // FIXME TODO: try a bigger texture size if it doesn't fit?\n          this._validateSize( width, height );\n          // Queue our resolution, which will be settled with .solveASync()\n          queueEntry = {\n            resolve: resolve,\n            reject: reject,\n            width: width,\n            height: height,\n          };\n        }\n        catch ( error ) {\n          reject( error );\n        };\n      });\n\n      if ( queueEntry ) {\n        queueEntry.promise = promise;\n        this._queue.push( queueEntry );\n      }\n\n      return promise;\n    }\n\n    /**\n     * Trigger resolution of any outstanding node allocation promises, i.e. those that have been created with {@link allocateASync}. Call this when you've added nodes, or their promises will not settle.\n     *\n     * This is by design, as postponing of the node allocation makes it possible for the texture manager to optimise packing of the texture space in the most efficient manner possible.\n     * @returns {external:Promise}\n     * @category allocation\n     * @throws {Error} You're trying to resolve a queue which hasn't been set up. Call {@link allocateASync} at least once before calling this.\n     * @example\n     * textureManager.solveASync().then( function( count ) {\n     *   console.log( `${ count } node allocations have been resolved` );\n     * });\n     */\n    solveASync() {\n      if ( ! Array.isArray( this._queue ) ) {\n        throw new Error( `You're trying to resolve a queue which hasn't been set up. Call allocateASync before using this.` );\n      }\n\n      const promises = [];\n\n      this._queue.forEach( entry => {\n        const { promise: promise, resolve: resolve, reject: reject, width: width, height: height } = entry;\n        const node = this._allocate( width, height );\n        resolve( node );\n        promises.push( promise );\n      });\n\n      this._queue = [];\n\n      return Promise.all( promises );\n    }\n\n    /**\n     * Low level helper to assert whether the given width and height will fit.\n     * @param {integer} width\n     * @param {integer} height\n     * @category allocation\n     * @throws {Error} Width of <number> is too large for these textures.\n     * @throws {Error} Height of <number> is too large for these textures.\n     * @private\n     * @ignore\n     */\n    _validateSize( width, height ) {\n      if ( width > this.textureSize ) {\n        throw new Error( `Width of ${ width } is too large for these textures` );\n      }\n\n      if ( height > this.textureSize ) {\n        throw new Error( `Height of ${ height } is too large for these textures` );\n      }\n    }\n\n    /**\n     * Low level helper to allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {KnapsackNode}\n     * @category allocation\n     * @private\n     * @ignore\n     */\n    _allocate( width, height ) {\n      let node = null;\n\n      // First try to get a node from the existing knapsacks\n      this.knapsacks.forEach( knapsack => {\n        if ( node === null || node === undefined ) {\n          node = knapsack.allocateNode( width, height );\n        }\n      });\n\n      // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n      if ( node === null ) {\n        let knapsack = this._addKnapsack( this.textureSize );\n        node = knapsack.allocateNode( width, height );\n      }\n\n      return node;\n    }\n\n    /**\n     * Release the given node.\n     * @param {KnapsackNode} node\n     * @category allocation\n     * @example\n     * textureManager.release( node );\n     */\n    release( node ) {\n      if ( node ) {\n        node.release();\n      }\n    }\n  }\n\n  return TextureManager;\n\n}));"],"sourceRoot":"/source/"}